@startuml
skinparam linetype ortho
skinparam packageStyle rectangle
skinparam ranksep 12

package "Dashboard Layer" {
  class DashboardGrid {
    +handleConnectRobot(robotId: string): Promise<void>
    +handleDisconnectRobot(robotId: string): void
    +handleAddWidget(type, robotId?, config?): void
    +handleRemoveWidget(widgetId: string): void
    +handleAddTab(tabName: string): void
    +handleSave(): void
  }
  class useRobotInfo {
    <<Custom Hook>>
    -context: MosaicContext (robotInfos: RobotInfo[])
    +updateRobotInfo(robotInfo: RobotInfo): void
  }
  class WidgetFactory {
    +renderWidget(widgetConfig: WidgetConfig): ReactElement | null
  }
  abstract class WidgetComponent {
    -widgetConfig: WidgetConfig
    +render(): ReactElement
  }
  struct WidgetConfig {
    +id: string
    +type: WidgetType
    +position: WidgetPositionConfig
    +connectors: RobotConnector[]
    +...others
  }
  struct DashboardConfig {
    + id: string
    + name: string
    + widgets: WidgetConfig[]
  }
  struct WidgetPositionConfig {
    +x: number
    +y: number
    +w: number
    +h: number
  }
  struct RobotConnector {
    +robotId: string
    +connectorId: string
    +parallel?: number
    +serialize(): string
    +{static}deserialize(serialized: string): RobotConnector
  }
}

package "Context Layer" {
  class MosaicContext {
    <<Context>>
    -storeManager: StoreManager
    -channelManager: ChannelManager
    -robotConnectionManager: RobotConnectionManager
    -webrtcConnectionManager: WebRTCConnectionManager
    -robotInfos: RobotInfo[]
    +getOrCreateStore(robotConnector: RobotConnector): MosaicStore
    +updateRobotInfo(robotInfo: RobotInfo): void
  }
  
  class RobotInfo {
    -id: string
    -name: string
    -wsConnected: boolean
    -rtcStates: RTCConnectionState
    -robotConfigs: RobotConfig
    +getRobotConfigs(): RobotConfig | undefined
  }

  enum RTCConnectionState {
      DISCONNECTED
      CONNECTING
      CONNECTED
      FAILED
      DISCONNECTING
    }
  
  struct RobotConfig {
    +id: string
    +name: string
    +connectors: ConnectorConfig[]
  }
  
  struct ConnectorConfig {
    +connectorId: string
    +dataType: string
    +params: any
  }

  MosaicContext *-- RobotInfo
  RobotInfo *-- RTCConnectionState
  RobotInfo *-- RobotConfig
  RobotConfig *-- ConnectorConfig
}

package "StoreManager" {
  class useMosaicStore {
    <<Custom Hook>>
    -context: MosaicContext (robotConfigs: Map<string, RobotConfig>)
    +getOrCreateStore(robotConnector: RobotConnector): MosaicStore
    +releaseStore(robotConnector: RobotConnector): void
  }
  
  class StoreManager {
    -mosaicStores: RobotConnectorRefMap<MosaicStore>
    +getOrCreateStore(robotConnector: RobotConnector, robotConfig: RobotConfig): MosaicStore
    +releaseStore(robotConnector: RobotConnector): void
    -resolveConnectorType(robotConnector: RobotConnector): string
  }
    
  class RobotConnectorRefMap<V> {
    -map: Map<string, V>
    -refCounts: Map<string, number>
    +get(key: RobotConnector): V | undefined
    +set(key: RobotConnector, value: V): void
    +incrementRefCount(key: RobotConnector): void
    +decrementRefCount(key: RobotConnector): void
    +getRefCount(key: RobotConnector): number
    +delete(key: RobotConnector): void
  }
  
  class StoreFactory {
    -storeFactories: Map<string, (robotConnector: RobotConnector) => MosaicStore>
    +registerMosaicStore<T extends MosaicStore>(StoreClass: new () => T): void
    +createStore(connectorType: string, robotConnector: RobotConnector): MosaicStore | null
  }
  
  useMosaicStore --> StoreManager
  StoreManager *-- RobotConnectorRefMap
  StoreManager --> StoreFactory
}

package "ChannelManager" {
  class useMosaicChannel {
    <<Custom Hook>>
    +addChannelRequirement(channelRequirement: ChannelRequirement): void
  }
  
  class ChannelManager {
    -activeChannels: Map<string, ChannelInfo>
    -channelRequirements: Map<string, ChannelRequirement[]>
    +registerActiveChannel(channelInfo: ChannelInfo): void
    +addChannelRequirement(channelRequirement: ChannelRequirement): void
    +removeChannelRequirement(channelRequirement: ChannelRequirement): void
    +getActiveChannel(robotConnector: RobotConnector): ChannelInfo | undefined
    +getAllActiveChannels(robotId: string): ChannelInfo[]
  }
 
  
  interface ChannelInfo {
    + channelType: "datachannel" | "media"
    + robotConnector: RobotConnector
    + rtcConnection: WebRTCConnection
    + rtcDataChannel: RTCDataChannel | null
    + mediaStream: MediaStream | null
  }
  
  interface ChannelRequirement {
    + store: MosaicStore
    + robotConnector: RobotConnector
  }

  useMosaicChannel --> ChannelManager
  ChannelManager *-- ChannelInfo
  ChannelManager *-- ChannelRequirement
}

package "WebRTCConnectionManager" {
  class useMosaicWebRTCConnection {
    <<Custom Hook>>
    +createConnection(robotId: string): Promise<void>
    +disconnectConnection(robotId: string): void
  }

  class WebRTCConnectionManager {
    -signalingServer: SignalingServer
    -connections: Map<string, WebRTCConnection>
    +createConnection(robotId: string, channelRequirements: ChannelRequirement[]): Promise<void>
    +disconnectConnection(robotId: string): void
    +getConnection(robotId: string): WebRTCConnection | undefined
    +removeDataChannel(robotConnector: RobotConnector): void
  }
  
  class WebRTCConnection {
    -rtcConnectionId: string
    -robotId: string
    -signalingServer: SignalingServer
    -peerConnection: RTCPeerConnection | null
    -dataChannels: Map<string, RTCDataChannel>
    -relatedStores: Map<string, MosaicStore>
    -mediaStreams: Map<string, MediaStream>
    +WebRTCConnection(rtcConnectionId: string, robotId: string)
    +getRtcConnectionId(): string
    +createConnection(channelRequirements: ChannelRequirement[]): void
    +startConnection(): Promise<void>
    +disconnect(): void
    +getPeerConnection(): RTCPeerConnection | null
    +receiveSdpAnswer(data): Promise<void>
    +receiveIceCandidate(data): Promise<void>
    -beforeConnection(): ConnectorRequirement[]
    -createPeerConnection(): RTCPeerConnection
    -createDataChannel(connectorId: string): RTCDataChannel
    -setupReceivableChannel(dc: RTCDataChannel, store: ReceivableStore): void
    -setupSendableChannel(dc: RTCDataChannel, store: SendableStore): void
    -createSdpOffer(): Promise<RTCSessionDescriptionInit>
    -onicecandidate(event: RTCPeerConnectionIceEvent): void
    -onconnectionstatechange(): void
    -onConnectionConnected(): void
    -onConnectionDisconnected(): void
    -onConnectionFailed(): void
    -resolveSdpAnswer(data): RTCSessionDescriptionInit
    -resolveIceCandidate(data): RTCIceCandidate
  }

  interface ConnectorRequirement {
    + robotConnector: RobotConnector
    + stores: MosaicStore[]
  }

  class SignalingServer {
    -ws: WebSocket | null
    -rtcConnections: Map<string, WebRTCConnection>
    +SignalingServer()
    +setRtcConnection(rtcConnection: WebRTCConnection): void
    +sendSdpOffer(rtcConnectionId: string, offer: RTCSessionDescriptionInit): Promise<void>
    +sendIceCandidate(rtcConnectionId: string, candidate: RTCIceCandidate): Promise<void>
    +sendCloseConnection(rtcConnectionId: string): Promise<void>
    +receiveSdpAnswer(data): Promise<void>
    +receiveIceCandidate(data): Promise<void>
  }

  useMosaicWebRTCConnection --> WebRTCConnectionManager
  WebRTCConnectionManager *-- WebRTCConnection
  WebRTCConnection --> ConnectorRequirement
}

package "Store Layer" {
  abstract class ConnectionSubscribable {
    -beforeConnectedSubscriberList: Map<string, Subscriber>
    -afterConnectedSubscriberList: Map<string, Subscriber>
    -afterDisconnectedSubscriberList: Map<string, Subscriber>
    -afterConnectionFailedSubscriberList: Map<string, Subscriber>
    +onBeforeConnected(subscriber: (robotId: string) => void): UnsubscribeFunction
    +onAfterConnected(subscriber: (robotId: string) => void): UnsubscribeFunction
    +onAfterDisconnected(subscriber: (robotId: string) => void): UnsubscribeFunction
    +onAfterConnectionFailed(subscriber: (robotId: string) => void): UnsubscribeFunction
    #{abstract}beforeConnected(robotId: string): void
    #{abstract}afterConnected(robotId: string): void
    #{abstract}afterDisconnected(robotId: string): void
    #{abstract}afterConnectionFailed(robotId: string): void
    +notifyBeforeConnected(robotId: string): void
    +notifyAfterConnected(robotId: string): void
    +notifyAfterDisconnected(robotId: string): void
    +notifyAfterConnectionFailed(robotId: string): void
  }

  abstract class MosaicStore {
    #{static}dataType: string
    #robotConnector: RobotConnector
    +MosaicStore(robotConnector: RobotConnector)
    +{static}getDataType(): string
    +{abstract}getStoreType(): "receivable" | "sendable" | "media"
    +getRobotConnector(): RobotConnector
  }

  MosaicStore -|> ConnectionSubscribable
  
  abstract class ReceivableStore extends MosaicStore {
  #{static} isParallelReceivable: boolean: false
  -subscriberList: Map<string, Subscriber>
  +getStoreType(): "receivable"
  +isParallelReceivable(): boolean
  +subscribe(subscriber: (data: ArrayBuffer) => Promise<void>): UnsubscribeFunction
  +notifySubscribers(data: ArrayBuffer): Promise<void>
  +{abstract}onSubscriberAdded(subscriber): void
  +{abstract}onSubscriberRemoved(subscriber): void
  -removeSubscriber(subscriberId: string): void
}
  
  abstract class SendableStore<V> extends MosaicStore {
    #dataChannel: RTCDataChannel | null
    +getStoreType(): "sendable"
    +{abstract}add(data: V): void
    #sendData(data: string): void
    +setDataChannel(channel: RTCDataChannel): void
  }
  
  abstract class MediaStreamStore extends MosaicStore {
    #stream: MediaStream | null
    +getStoreType(): "media"
    +{abstract}setMediaStream(stream: MediaStream): void
  }
  
  class ConnectionCheckingStore extends ReceivableStore, SendableStore {
    +{static} dataType: "connection_check"
    -intervalId: number | null
    +afterConnected(): void
    +afterDisconnected(): void
    -connectionCheckInterval(): void
    -replyCheck(data: ArrayBuffer): void
  }
}

' Dashboard Layer relationships
DashboardGrid --> WidgetFactory
WidgetFactory --> WidgetComponent
WidgetConfig -* WidgetComponent
DashboardConfig -* DashboardGrid
DashboardConfig *-- WidgetConfig
WidgetConfig *-- RobotConnector
WidgetConfig *-- WidgetPositionConfig

' Dashboard to Hooks
WidgetComponent --> useMosaicStore

' Context contains Managers
'MosaicContext *- StoreManager
'MosaicContext *-- ChannelManager
'MosaicContext *-- RobotConnectionManager
'MosaicContext *-- WebRTCConnectionManager

' Store Factory relationships
StoreFactory ..> MosaicStore

@enduml